{"version":3,"file":"high-tree.iife.js","sources":["../high-tree.js"],"sourcesContent":["export default class VirtualTree {\r\n    constructor(element, options) {\r\n        this.container = element;\r\n        this.options = {\r\n            data: options.data || [],\r\n            rowHeight: options.rowHeight || 40,\r\n            height: options.height || 550,\r\n            lazy: options.lazy || false,\r\n\r\n            // Callbacks\r\n            onLoadData: options.onLoadData || null,\r\n            onClick: options.onClick || null,\r\n            onExpand: options.onExpand || null,\r\n            onCollapse: options.onCollapse || null,\r\n            onSelect: options.onSelect || null,\r\n            onCheck: options.onCheck || null,\r\n            onDrop: options.onDrop || null,\r\n            onContextMenu: options.onContextMenu || null,\r\n\r\n            // Features\r\n            renderNode: options.renderNode || null,\r\n            selectable: options.selectable || false,\r\n            multiSelect: options.multiSelect || false,\r\n            cascadeSelect: options.cascadeSelect || false,\r\n            checkbox: options.checkbox || false,\r\n            draggable: options.draggable || false,\r\n            enableDefaultDragDrop: options.enableDefaultDragDrop !== undefined ? options.enableDefaultDragDrop : true, // default: true\r\n            filter: options.filter || null,\r\n        };\r\n\r\n        // Internal state\r\n        this.state = {\r\n            treeData: [...this.options.data],\r\n            expandedIds: new Set(),\r\n            loadingIds: new Set(),\r\n            selectedIds: new Set(),\r\n            checkedIds: new Set(),\r\n            searchTerm: '',\r\n            scrollTop: 0,\r\n            visibleNodes: [],\r\n            focusedId: null,\r\n            focusedIndex: -1,\r\n            draggingNode: null,\r\n            dragOverNode: null,\r\n            customFilter: this.options.filter,\r\n        };\r\n\r\n        this.init();\r\n    }\r\n\r\n    // Initialize DOM structure and event bindings\r\n    init() {\r\n        this.container.innerHTML = `\r\n      <div class=\"flex flex-col border border-slate-200 rounded-xl bg-white shadow-sm overflow-hidden\" style=\"height: ${this.options.height}px\" tabindex=\"0\" id=\"tree-container\">\r\n        <!-- Search Bar -->\r\n        <div class=\"p-3 border-b border-slate-100 bg-slate-50/50 flex items-center gap-2\">\r\n          <div class=\"relative flex-1\">\r\n            <svg class=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"11\" cy=\"11\" r=\"8\"/><path d=\"m21 21-4.3-4.3\"/></svg>\r\n            <input type=\"text\" id=\"tree-search\" placeholder=\"노드 이름으로 검색...\" class=\"w-full pl-9 pr-9 py-1.5 bg-white border border-slate-200 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all\">\r\n          </div>\r\n          <div id=\"tree-count\" class=\"text-[11px] font-medium text-slate-400 px-2 uppercase tracking-wider\">0 items</div>\r\n        </div>\r\n\r\n        <!-- Scroll Viewport -->\r\n        <div id=\"tree-viewport\" class=\"relative flex-1 overflow-auto custom-scrollbar\">\r\n          <div id=\"tree-spacer\" style=\"width: 100%; pointer-events: none;\"></div>\r\n          <div id=\"tree-content-layer\" class=\"absolute top-0 left-0 w-full tree-node-container\"></div>\r\n        </div>\r\n      </div>\r\n    `;\r\n\r\n        this.treeContainer = this.container.querySelector('#tree-container');\r\n        this.viewport = this.container.querySelector('#tree-viewport');\r\n        this.spacer = this.container.querySelector('#tree-spacer');\r\n        this.contentLayer = this.container.querySelector('#tree-content-layer');\r\n        this.searchInput = this.container.querySelector('#tree-search');\r\n        this.countDisplay = this.container.querySelector('#tree-count');\r\n\r\n        // Event listeners\r\n        this.viewport.addEventListener('scroll', () => {\r\n            this.state.scrollTop = this.viewport.scrollTop;\r\n            this.render();\r\n        });\r\n\r\n        this.searchInput.addEventListener('input', (e) => {\r\n            this.setState({ searchTerm: e.target.value, scrollTop: 0 });\r\n            this.viewport.scrollTop = 0;\r\n        });\r\n\r\n        // Node click (event delegation)\r\n        this.contentLayer.addEventListener('click', (e) => {\r\n            // Checkbox click\r\n            if (e.target.closest('.tree-checkbox')) {\r\n                const nodeEl = e.target.closest('[data-id]');\r\n                if (nodeEl) {\r\n                    e.stopPropagation();\r\n                    this.handleCheckboxClick(nodeEl.dataset.id, e);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // Node click\r\n            const nodeEl = e.target.closest('[data-id]');\r\n            if (nodeEl) {\r\n                const nodeId = nodeEl.dataset.id;\r\n                this.handleNodeClick(nodeId, e);\r\n            }\r\n        });\r\n\r\n        // Context menu\r\n        if (this.options.onContextMenu) {\r\n            this.contentLayer.addEventListener('contextmenu', (e) => {\r\n                const nodeEl = e.target.closest('[data-id]');\r\n                if (nodeEl) {\r\n                    e.preventDefault();\r\n                    const node = this.findNodeById(nodeEl.dataset.id);\r\n                    if (node) {\r\n                        this.options.onContextMenu(node, e);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Drag and drop\r\n        if (this.options.draggable) {\r\n            this.contentLayer.addEventListener('dragstart', (e) => {\r\n                const nodeEl = e.target.closest('[data-id]');\r\n                if (nodeEl) {\r\n                    this.handleDragStart(e, nodeEl.dataset.id);\r\n                }\r\n            });\r\n\r\n            this.contentLayer.addEventListener('dragover', (e) => {\r\n                e.preventDefault(); // Required for drop event to fire\r\n                const nodeEl = e.target.closest('[data-id]');\r\n                if (nodeEl) {\r\n                    this.handleDragOver(e, nodeEl.dataset.id);\r\n                }\r\n            });\r\n\r\n            this.contentLayer.addEventListener('drop', (e) => {\r\n                e.preventDefault(); // Prevent default behavior\r\n                const nodeEl = e.target.closest('[data-id]');\r\n                if (nodeEl) {\r\n                    this.handleDrop(e, nodeEl.dataset.id);\r\n                }\r\n            });\r\n\r\n            this.contentLayer.addEventListener('dragleave', () => {\r\n                this.state.dragOverNode = null;\r\n                this.render();\r\n            });\r\n        }\r\n\r\n        // Keyboard navigation\r\n        this.treeContainer.addEventListener('keydown', (e) => {\r\n            this.handleKeyDown(e);\r\n        });\r\n\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // State change function\r\n    setState(newState) {\r\n        this.state = { ...this.state, ...newState };\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // Flatten tree and apply filtering\r\n    updateVisibleNodes() {\r\n        const result = [];\r\n        this.flattenFilteredTree(this.state.treeData, 0, result);\r\n        this.state.visibleNodes = result;\r\n\r\n        // Set total height\r\n        const totalHeight = result.length * this.options.rowHeight;\r\n        this.spacer.style.height = `${totalHeight}px`;\r\n        this.countDisplay.textContent = `${result.length} items`;\r\n\r\n        this.render();\r\n    }\r\n\r\n    flattenFilteredTree(nodes, level = 0, result = []) {\r\n        let hasMatchInBranch = false;\r\n        const currentSearch = this.state.searchTerm.trim().toLowerCase();\r\n\r\n        for (const node of nodes) {\r\n            // Apply custom filter\r\n            if (this.state.customFilter && !this.state.customFilter(node)) {\r\n                continue;\r\n            }\r\n\r\n            const isMatch = currentSearch ? node.label.toLowerCase().includes(currentSearch) : false;\r\n            const tempSubResult = [];\r\n            let childHasMatch = false;\r\n\r\n            if (node.children) {\r\n                childHasMatch = this.flattenFilteredTree(node.children, level + 1, tempSubResult);\r\n            }\r\n\r\n            if (!currentSearch || isMatch || childHasMatch) {\r\n                result.push({ ...node, level, isMatch });\r\n                if ((currentSearch && childHasMatch) || (!currentSearch && this.state.expandedIds.has(node.id))) {\r\n                    result.push(...tempSubResult);\r\n                }\r\n                if (isMatch || childHasMatch) hasMatchInBranch = true;\r\n            }\r\n        }\r\n        return hasMatchInBranch;\r\n    }\r\n\r\n    // Node click handler\r\n    async handleNodeClick(nodeId, event) {\r\n        const node = this.findNodeById(nodeId);\r\n        if (!node) return;\r\n\r\n        // onClick callback\r\n        if (this.options.onClick) {\r\n            this.options.onClick(node, event);\r\n        }\r\n\r\n        // Selection feature\r\n        if (this.options.selectable) {\r\n            if (this.options.multiSelect && (event.ctrlKey || event.metaKey)) {\r\n                // Multi-select\r\n                if (this.state.selectedIds.has(nodeId)) {\r\n                    this.state.selectedIds.delete(nodeId);\r\n                    // Cascade deselect\r\n                    if (this.options.cascadeSelect) {\r\n                        this.cascadeDeselectChildren(node);\r\n                    }\r\n                } else {\r\n                    this.state.selectedIds.add(nodeId);\r\n                    // Cascade select\r\n                    if (this.options.cascadeSelect) {\r\n                        this.cascadeSelectChildren(node);\r\n                    }\r\n                }\r\n            } else {\r\n                // Single select\r\n                this.state.selectedIds.clear();\r\n                this.state.selectedIds.add(nodeId);\r\n                // Cascade select\r\n                if (this.options.cascadeSelect) {\r\n                    this.cascadeSelectChildren(node);\r\n                }\r\n            }\r\n\r\n            this.state.focusedId = nodeId;\r\n            this.state.focusedIndex = this.state.visibleNodes.findIndex(n => n.id === nodeId);\r\n\r\n            if (this.options.onSelect) {\r\n                this.options.onSelect(this.getSelectedNodes());\r\n            }\r\n            this.render();\r\n        }\r\n\r\n        // Expand/collapse\r\n        if (this.state.expandedIds.has(nodeId)) {\r\n            this.state.expandedIds.delete(nodeId);\r\n            if (this.options.onCollapse) {\r\n                this.options.onCollapse(node);\r\n            }\r\n            this.setState({});\r\n        } else {\r\n            // Lazy Load\r\n            if (this.options.lazy && node.hasChildren && !node.children) {\r\n                this.state.loadingIds.add(nodeId);\r\n                this.render();\r\n\r\n                try {\r\n                    const newChildren = await this.options.onLoadData(node);\r\n\r\n                    // Update data structure\r\n                    const updateRecursive = (list) => {\r\n                        return list.map(n => {\r\n                            if (n.id === nodeId) return { ...n, children: newChildren };\r\n                            if (n.children) return { ...n, children: updateRecursive(n.children) };\r\n                            return n;\r\n                        });\r\n                    };\r\n                    this.state.treeData = updateRecursive(this.state.treeData);\r\n                    this.state.expandedIds.add(nodeId);\r\n\r\n                    // If parent is checked, check all newly loaded children\r\n                    if (this.options.checkbox && this.state.checkedIds.has(nodeId)) {\r\n                        const checkNewChildren = (children) => {\r\n                            children.forEach(child => {\r\n                                this.state.checkedIds.add(child.id);\r\n                                if (child.children) {\r\n                                    checkNewChildren(child.children);\r\n                                }\r\n                            });\r\n                        };\r\n                        checkNewChildren(newChildren);\r\n                    }\r\n\r\n                    // If parent is selected and cascadeSelect is enabled, select all newly loaded children\r\n                    if (this.options.selectable && this.options.cascadeSelect && this.state.selectedIds.has(nodeId)) {\r\n                        const selectNewChildren = (children) => {\r\n                            children.forEach(child => {\r\n                                this.state.selectedIds.add(child.id);\r\n                                if (child.children) {\r\n                                    selectNewChildren(child.children);\r\n                                }\r\n                            });\r\n                        };\r\n                        selectNewChildren(newChildren);\r\n                    }\r\n\r\n                    if (this.options.onExpand) {\r\n                        this.options.onExpand(node);\r\n                    }\r\n                } finally {\r\n                    this.state.loadingIds.delete(nodeId);\r\n                    this.setState({});\r\n                }\r\n            } else {\r\n                this.state.expandedIds.add(nodeId);\r\n                if (this.options.onExpand) {\r\n                    this.options.onExpand(node);\r\n                }\r\n                this.setState({});\r\n            }\r\n        }\r\n    }\r\n\r\n    // Checkbox click handler\r\n    handleCheckboxClick(nodeId, event) {\r\n        if (!this.options.checkbox) return;\r\n\r\n        const isChecked = this.state.checkedIds.has(nodeId);\r\n\r\n        if (isChecked) {\r\n            this.uncheckNode(nodeId, true);\r\n        } else {\r\n            this.checkNode(nodeId, true);\r\n        }\r\n\r\n        if (this.options.onCheck) {\r\n            this.options.onCheck(this.getCheckedNodes());\r\n        }\r\n\r\n        // Explicitly render to update UI\r\n        this.render();\r\n    }\r\n\r\n    // Drag and drop handlers\r\n    handleDragStart(event, nodeId) {\r\n        this.state.draggingNode = nodeId;\r\n        event.dataTransfer.effectAllowed = 'move';\r\n        event.dataTransfer.setData('text/plain', nodeId);\r\n    }\r\n\r\n    handleDragOver(event, nodeId) {\r\n        if (this.state.draggingNode === nodeId) return;\r\n\r\n        // Enable drop\r\n        event.dataTransfer.dropEffect = 'move';\r\n\r\n        // Update state only (no render call to avoid interfering with drop event)\r\n        if (this.state.dragOverNode !== nodeId) {\r\n            this.state.dragOverNode = nodeId;\r\n\r\n            // Optimize rendering with requestAnimationFrame\r\n            if (!this._dragOverRenderScheduled) {\r\n                this._dragOverRenderScheduled = true;\r\n                requestAnimationFrame(() => {\r\n                    this.render();\r\n                    this._dragOverRenderScheduled = false;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    handleDrop(event, targetNodeId) {\r\n        console.log('handleDrop called', { draggedNodeId: this.state.draggingNode, targetNodeId });\r\n        const draggedNodeId = this.state.draggingNode;\r\n\r\n        if (draggedNodeId && draggedNodeId !== targetNodeId) {\r\n            const draggedNode = this.findNodeById(draggedNodeId);\r\n            const targetNode = this.findNodeById(targetNodeId);\r\n            console.log('Found nodes:', { draggedNode, targetNode });\r\n\r\n            if (draggedNode && targetNode) {\r\n                // Default drag and drop handling\r\n                if (this.options.enableDefaultDragDrop) {\r\n                    console.log('Default drag-drop enabled:', this.options.enableDefaultDragDrop);\r\n\r\n                    // Validation: cannot drop onto itself or descendants\r\n                    const isDescendant = this.isNodeDescendant(draggedNode.id, targetNode.id);\r\n                    console.log('Is descendant?', isDescendant);\r\n\r\n                    if (!isDescendant) {\r\n                        // Execute node move\r\n                        console.log('Removing node:', draggedNode.id);\r\n                        const removed = this.removeNodeFromTree(this.state.treeData, draggedNode.id);\r\n                        console.log('Removed node:', removed);\r\n\r\n                        if (removed) {\r\n                            console.log('Inserting node into:', targetNode.id);\r\n                            const inserted = this.insertNodeInTree(this.state.treeData, targetNode.id, removed, 'inside');\r\n                            console.log('Insert result:', inserted);\r\n\r\n                            // Explicitly update rendering\r\n                            this.updateVisibleNodes();\r\n                            console.log('✅ Node moved successfully!');\r\n                        } else {\r\n                            console.error('❌ Failed to remove node');\r\n                        }\r\n                    } else {\r\n                        console.warn('⚠️ Cannot drop node onto its descendant');\r\n                    }\r\n                }\r\n\r\n                // Call custom callback (after default action)\r\n                if (this.options.onDrop) {\r\n                    this.options.onDrop(draggedNode, targetNode, 'inside');\r\n                }\r\n            } else {\r\n                console.error('❌ Could not find dragged or target node');\r\n            }\r\n        }\r\n\r\n        this.state.draggingNode = null;\r\n        this.state.dragOverNode = null;\r\n        this.render();\r\n    }\r\n\r\n    // Keyboard navigation\r\n    handleKeyDown(event) {\r\n        if (!this.state.visibleNodes.length) return;\r\n\r\n        let handled = false;\r\n\r\n        switch (event.key) {\r\n            case 'ArrowDown':\r\n                this.moveFocus(1);\r\n                handled = true;\r\n                break;\r\n            case 'ArrowUp':\r\n                this.moveFocus(-1);\r\n                handled = true;\r\n                break;\r\n            case 'ArrowRight':\r\n                if (this.state.focusedId) {\r\n                    this.expandNode(this.state.focusedId);\r\n                    handled = true;\r\n                }\r\n                break;\r\n            case 'ArrowLeft':\r\n                if (this.state.focusedId) {\r\n                    this.collapseNode(this.state.focusedId);\r\n                    handled = true;\r\n                }\r\n                break;\r\n            case 'Enter':\r\n                if (this.state.focusedId) {\r\n                    this.handleNodeClick(this.state.focusedId, event);\r\n                    handled = true;\r\n                }\r\n                break;\r\n            case ' ':\r\n                if (this.options.selectable && this.state.focusedId) {\r\n                    event.preventDefault();\r\n                    const node = this.findNodeById(this.state.focusedId);\r\n                    if (node) {\r\n                        this.handleNodeClick(this.state.focusedId, event);\r\n                    }\r\n                    handled = true;\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (handled) {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    moveFocus(direction) {\r\n        if (this.state.focusedIndex === -1 && this.state.visibleNodes.length > 0) {\r\n            this.state.focusedIndex = 0;\r\n        } else {\r\n            this.state.focusedIndex = Math.max(0, Math.min(this.state.visibleNodes.length - 1, this.state.focusedIndex + direction));\r\n        }\r\n\r\n        if (this.state.visibleNodes[this.state.focusedIndex]) {\r\n            this.state.focusedId = this.state.visibleNodes[this.state.focusedIndex].id;\r\n            this.render();\r\n            this.scrollToFocused();\r\n        }\r\n    }\r\n\r\n    scrollToFocused() {\r\n        if (this.state.focusedIndex === -1) return;\r\n\r\n        const { rowHeight } = this.options;\r\n        const focusedTop = this.state.focusedIndex * rowHeight;\r\n        const focusedBottom = focusedTop + rowHeight;\r\n        const viewportTop = this.viewport.scrollTop;\r\n        const viewportBottom = viewportTop + this.viewport.clientHeight;\r\n\r\n        if (focusedTop < viewportTop) {\r\n            this.viewport.scrollTop = focusedTop;\r\n        } else if (focusedBottom > viewportBottom) {\r\n            this.viewport.scrollTop = focusedBottom - this.viewport.clientHeight;\r\n        }\r\n    }\r\n\r\n    // Highlight search term\r\n    getHighlightedText(text) {\r\n        if (!this.state.searchTerm) return text;\r\n        const regex = new RegExp(`(${this.state.searchTerm})`, 'gi');\r\n        return text.replace(regex, '<mark>$1</mark>');\r\n    }\r\n\r\n    // Actual DOM rendering\r\n    render() {\r\n        const { visibleNodes, scrollTop } = this.state;\r\n        const { rowHeight, height } = this.options;\r\n\r\n        const startIndex = Math.floor(scrollTop / rowHeight);\r\n        const endIndex = Math.min(startIndex + Math.ceil(height / rowHeight) + 1, visibleNodes.length);\r\n\r\n        const displayNodes = visibleNodes.slice(startIndex, endIndex);\r\n\r\n        this.contentLayer.style.transform = `translateY(${startIndex * rowHeight}px)`;\r\n\r\n        if (displayNodes.length === 0) {\r\n            this.contentLayer.innerHTML = `\r\n        <div class=\"flex flex-col items-center justify-center py-20 text-slate-400\">\r\n          <p class=\"text-sm\">검색 결과가 없습니다.</p>\r\n        </div>\r\n      `;\r\n            return;\r\n        }\r\n\r\n        this.contentLayer.innerHTML = displayNodes.map(node => {\r\n            const isExpanded = this.state.expandedIds.has(node.id) || (this.state.searchTerm && !node.isMatch);\r\n            const isLoading = this.state.loadingIds.has(node.id);\r\n            const hasChildren = node.children || (this.options.lazy && node.hasChildren);\r\n            const isSelected = this.state.selectedIds.has(node.id);\r\n            const isFocused = this.state.focusedId === node.id;\r\n            const isChecked = this.state.checkedIds.has(node.id);\r\n            const isDragOver = this.state.dragOverNode === node.id;\r\n\r\n            // Custom render function\r\n            const content = this.options.renderNode\r\n                ? this.options.renderNode(node, this.state.searchTerm)\r\n                : `\r\n          <div class=\"flex items-center gap-2 overflow-hidden\">\r\n            ${hasChildren\r\n                    ? `<svg class=\"w-4 h-4 ${isExpanded ? 'fill-blue-100 text-blue-500' : 'text-slate-400'}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z\"/></svg>`\r\n                    : `<svg class=\"w-4 h-4 text-slate-300\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z\"/><polyline points=\"14 2 14 8 20 8\"/></svg>`\r\n                }\r\n            <span class=\"text-sm text-slate-700 select-none truncate\">${this.getHighlightedText(node.label)}</span>\r\n          </div>\r\n        `;\r\n\r\n            return `\r\n        <div \r\n          data-id=\"${node.id}\"\r\n          class=\"flex items-center px-2 hover:bg-blue-50/50 cursor-pointer transition-colors ${node.isMatch ? 'bg-blue-50/30' : ''} ${isSelected ? 'bg-blue-100 border-l-2 border-blue-500' : ''} ${isFocused ? 'ring-1 ring-blue-400' : ''} ${isDragOver ? 'bg-green-100' : ''}\"\r\n          style=\"height: ${rowHeight}px; padding-left: ${node.level * 20 + 8}px\"\r\n          ${this.options.draggable ? 'draggable=\"true\"' : ''}\r\n        >\r\n          ${this.options.checkbox ? `\r\n            <div class=\"tree-checkbox mr-2\">\r\n              <input type=\"checkbox\" ${isChecked ? 'checked' : ''} class=\"w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer\">\r\n            </div>\r\n          ` : ''}\r\n          \r\n          <div class=\"w-5 h-5 flex items-center justify-center mr-1\">\r\n            ${isLoading\r\n                    ? `<svg class=\"w-3 h-3 animate-spin text-blue-500\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"3\"><path d=\"M21 12a9 9 0 1 1-6.219-8.56\"/></svg>`\r\n                    : hasChildren\r\n                        ? `<svg class=\"w-4 h-4 text-slate-400\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">${isExpanded ? '<path d=\"m6 9 6 6 6-6\"/>' : '<path d=\"m9 18 6-6-6-6\"/>'}</svg>`\r\n                        : ''\r\n                }\r\n          </div>\r\n          ${content}\r\n        </div>\r\n      `;\r\n        }).join('');\r\n    }\r\n\r\n    // ========== Public API ==========\r\n\r\n    // Find node by ID\r\n    findNodeById(nodeId) {\r\n        const find = (nodes) => {\r\n            for (const n of nodes) {\r\n                if (n.id === nodeId) return n;\r\n                if (n.children) {\r\n                    const found = find(n.children);\r\n                    if (found) return found;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        return find(this.state.treeData);\r\n    }\r\n\r\n    // Expand node\r\n    expandNode(nodeId) {\r\n        if (!this.state.expandedIds.has(nodeId)) {\r\n            this.state.expandedIds.add(nodeId);\r\n            const node = this.findNodeById(nodeId);\r\n            if (node && this.options.onExpand) {\r\n                this.options.onExpand(node);\r\n            }\r\n            this.setState({});\r\n        }\r\n    }\r\n\r\n    // Collapse node\r\n    collapseNode(nodeId) {\r\n        if (this.state.expandedIds.has(nodeId)) {\r\n            this.state.expandedIds.delete(nodeId);\r\n            const node = this.findNodeById(nodeId);\r\n            if (node && this.options.onCollapse) {\r\n                this.options.onCollapse(node);\r\n            }\r\n            this.setState({});\r\n        }\r\n    }\r\n\r\n    // Expand all (async with lazy loading support)\r\n    async expandAll() {\r\n        if (!this.options.lazy) {\r\n            // Non-lazy: simply expand all nodes\r\n            const expandRecursive = (nodes) => {\r\n                nodes.forEach(node => {\r\n                    if (node.children || node.hasChildren) {\r\n                        this.state.expandedIds.add(node.id);\r\n                    }\r\n                    if (node.children) {\r\n                        expandRecursive(node.children);\r\n                    }\r\n                });\r\n            };\r\n            expandRecursive(this.state.treeData);\r\n            this.updateVisibleNodes();\r\n        } else {\r\n            // Lazy: load and expand in parallel (performance optimization)\r\n            const expandAndLoadRecursive = async (nodes) => {\r\n                // Process same-level nodes in parallel\r\n                const loadPromises = nodes.map(async (node) => {\r\n                    if (node.children || node.hasChildren) {\r\n                        this.state.expandedIds.add(node.id);\r\n\r\n                        // Load children if not yet loaded\r\n                        if (node.hasChildren && !node.children) {\r\n                            try {\r\n                                this.state.loadingIds.add(node.id);\r\n                                this.render();\r\n\r\n                                const newChildren = await this.options.onLoadData(node);\r\n\r\n                                // Update data structure\r\n                                const updateRecursive = (list) => {\r\n                                    return list.map(n => {\r\n                                        if (n.id === node.id) return { ...n, children: newChildren };\r\n                                        if (n.children) return { ...n, children: updateRecursive(n.children) };\r\n                                        return n;\r\n                                    });\r\n                                };\r\n                                this.state.treeData = updateRecursive(this.state.treeData);\r\n\r\n                                // Inherit checkbox state\r\n                                if (this.options.checkbox && this.state.checkedIds.has(node.id)) {\r\n                                    const checkChildren = (children) => {\r\n                                        children.forEach(child => {\r\n                                            this.state.checkedIds.add(child.id);\r\n                                            if (child.children) checkChildren(child.children);\r\n                                        });\r\n                                    };\r\n                                    checkChildren(newChildren);\r\n                                }\r\n\r\n                                // Inherit selection state\r\n                                if (this.options.selectable && this.options.cascadeSelect && this.state.selectedIds.has(node.id)) {\r\n                                    const selectChildren = (children) => {\r\n                                        children.forEach(child => {\r\n                                            this.state.selectedIds.add(child.id);\r\n                                            if (child.children) selectChildren(child.children);\r\n                                        });\r\n                                    };\r\n                                    selectChildren(newChildren);\r\n                                }\r\n\r\n                                this.state.loadingIds.delete(node.id);\r\n\r\n                                // Recursively expand children in parallel\r\n                                await expandAndLoadRecursive(newChildren);\r\n                            } catch (error) {\r\n                                console.error('Error loading children in expandAll:', error);\r\n                                this.state.loadingIds.delete(node.id);\r\n                            }\r\n                        } else if (node.children) {\r\n                            // Expand already loaded children in parallel\r\n                            await expandAndLoadRecursive(node.children);\r\n                        }\r\n                    }\r\n                });\r\n\r\n                // Process all nodes in parallel\r\n                await Promise.all(loadPromises);\r\n            };\r\n\r\n            await expandAndLoadRecursive(this.state.treeData);\r\n            this.updateVisibleNodes();\r\n        }\r\n    }\r\n\r\n    // Collapse all\r\n    collapseAll() {\r\n        this.state.expandedIds.clear();\r\n        this.setState({});\r\n    }\r\n\r\n    // Select node\r\n    selectNode(nodeId) {\r\n        if (!this.options.selectable) return;\r\n\r\n        if (!this.options.multiSelect) {\r\n            this.state.selectedIds.clear();\r\n        }\r\n        this.state.selectedIds.add(nodeId);\r\n\r\n        if (this.options.onSelect) {\r\n            this.options.onSelect(this.getSelectedNodes());\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    // Unselect node\r\n    unselectNode(nodeId) {\r\n        this.state.selectedIds.delete(nodeId);\r\n\r\n        if (this.options.onSelect) {\r\n            this.options.onSelect(this.getSelectedNodes());\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    // Get selected nodes\r\n    getSelectedNodes() {\r\n        return Array.from(this.state.selectedIds).map(id => this.findNodeById(id)).filter(Boolean);\r\n    }\r\n\r\n    // Clear all selections\r\n    clearSelection() {\r\n        this.state.selectedIds.clear();\r\n\r\n        if (this.options.onSelect) {\r\n            this.options.onSelect([]);\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    // Check node\r\n    checkNode(nodeId, cascade = false) {\r\n        if (!this.options.checkbox) return;\r\n\r\n        this.state.checkedIds.add(nodeId);\r\n\r\n        if (cascade) {\r\n            const node = this.findNodeById(nodeId);\r\n            if (node && node.children) {\r\n                const checkChildren = (children) => {\r\n                    children.forEach(child => {\r\n                        this.state.checkedIds.add(child.id);\r\n                        if (child.children) {\r\n                            checkChildren(child.children);\r\n                        }\r\n                    });\r\n                };\r\n                checkChildren(node.children);\r\n            }\r\n        }\r\n\r\n        // Don't render here, let the caller handle it\r\n    }\r\n\r\n    // Uncheck node\r\n    uncheckNode(nodeId, cascade = false) {\r\n        if (!this.options.checkbox) return;\r\n\r\n        this.state.checkedIds.delete(nodeId);\r\n\r\n        if (cascade) {\r\n            const node = this.findNodeById(nodeId);\r\n            if (node && node.children) {\r\n                const uncheckChildren = (children) => {\r\n                    children.forEach(child => {\r\n                        this.state.checkedIds.delete(child.id);\r\n                        if (child.children) {\r\n                            uncheckChildren(child.children);\r\n                        }\r\n                    });\r\n                };\r\n                uncheckChildren(node.children);\r\n            }\r\n        }\r\n\r\n        // Don't render here, let the caller handle it\r\n    }\r\n\r\n    // Get checked nodes\r\n    getCheckedNodes() {\r\n        return Array.from(this.state.checkedIds).map(id => this.findNodeById(id)).filter(Boolean);\r\n    }\r\n\r\n    // Set filter\r\n    setFilter(filterFn) {\r\n        this.state.customFilter = filterFn;\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // Clear filter\r\n    clearFilter() {\r\n        this.state.customFilter = null;\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // Refresh\r\n    refresh() {\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // Update data\r\n    setData(newData) {\r\n        this.state.treeData = [...newData];\r\n        this.updateVisibleNodes();\r\n    }\r\n\r\n    // Get all data\r\n    getData() {\r\n        return this.state.treeData;\r\n    }\r\n\r\n    // Cascade select children (helper method)\r\n    cascadeSelectChildren(node) {\r\n        if (node.children) {\r\n            node.children.forEach(child => {\r\n                this.state.selectedIds.add(child.id);\r\n                if (child.children) {\r\n                    this.cascadeSelectChildren(child);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // Cascade deselect children (helper method)\r\n    cascadeDeselectChildren(node) {\r\n        if (node.children) {\r\n            node.children.forEach(child => {\r\n                this.state.selectedIds.delete(child.id);\r\n                if (child.children) {\r\n                    this.cascadeDeselectChildren(child);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // Helper: Remove node from tree (for drag-and-drop)\r\n    removeNodeFromTree(nodes, nodeId) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].id === nodeId) {\r\n                return nodes.splice(i, 1)[0];\r\n            }\r\n            if (nodes[i].children) {\r\n                const removed = this.removeNodeFromTree(nodes[i].children, nodeId);\r\n                if (removed) return removed;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Helper: Insert node into tree (for drag-and-drop)\r\n    insertNodeInTree(nodes, targetId, nodeToInsert, position = 'inside') {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].id === targetId) {\r\n                if (position === 'inside') {\r\n                    if (!nodes[i].children) {\r\n                        nodes[i].children = [];\r\n                    }\r\n                    nodes[i].children.push(nodeToInsert);\r\n                } else if (position === 'before') {\r\n                    nodes.splice(i, 0, nodeToInsert);\r\n                } else if (position === 'after') {\r\n                    nodes.splice(i + 1, 0, nodeToInsert);\r\n                }\r\n                return true;\r\n            }\r\n            if (nodes[i].children) {\r\n                if (this.insertNodeInTree(nodes[i].children, targetId, nodeToInsert, position)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Helper: Check if ancestorId is ancestor of descendantId\r\n    isNodeDescendant(ancestorId, descendantId) {\r\n        const findNode = (nodes, id) => {\r\n            for (const node of nodes) {\r\n                if (node.id === id) return node;\r\n                if (node.children) {\r\n                    const found = findNode(node.children, id);\r\n                    if (found) return found;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        const checkDescendant = (node, targetId) => {\r\n            if (node.id === targetId) return true;\r\n            if (node.children) {\r\n                return node.children.some(child => checkDescendant(child, targetId));\r\n            }\r\n            return false;\r\n        };\r\n\r\n        const ancestorNode = findNode(this.state.treeData, ancestorId);\r\n        return ancestorNode && checkDescendant(ancestorNode, descendantId);\r\n    }\r\n}\r\n"],"names":["constructor","element","options","this","container","data","rowHeight","height","lazy","onLoadData","onClick","onExpand","onCollapse","onSelect","onCheck","onDrop","onContextMenu","renderNode","selectable","multiSelect","cascadeSelect","checkbox","draggable","enableDefaultDragDrop","filter","state","treeData","expandedIds","Set","loadingIds","selectedIds","checkedIds","searchTerm","scrollTop","visibleNodes","focusedId","focusedIndex","draggingNode","dragOverNode","customFilter","init","innerHTML","treeContainer","querySelector","viewport","spacer","contentLayer","searchInput","countDisplay","addEventListener","render","e","setState","target","value","closest","nodeEl","stopPropagation","handleCheckboxClick","dataset","id","nodeId","handleNodeClick","preventDefault","node","findNodeById","handleDragStart","handleDragOver","handleDrop","handleKeyDown","updateVisibleNodes","newState","result","flattenFilteredTree","totalHeight","length","style","textContent","nodes","level","hasMatchInBranch","currentSearch","trim","toLowerCase","isMatch","label","includes","tempSubResult","childHasMatch","children","push","has","event","ctrlKey","metaKey","delete","cascadeDeselectChildren","add","cascadeSelectChildren","clear","findIndex","n","getSelectedNodes","hasChildren","newChildren","updateRecursive","list","map","checkNewChildren","forEach","child","selectNewChildren","uncheckNode","checkNode","getCheckedNodes","dataTransfer","effectAllowed","setData","dropEffect","_dragOverRenderScheduled","requestAnimationFrame","targetNodeId","draggedNodeId","draggedNode","targetNode","isDescendant","isNodeDescendant","console","warn","removed","removeNodeFromTree","insertNodeInTree","error","handled","key","moveFocus","expandNode","collapseNode","direction","Math","max","min","scrollToFocused","focusedTop","focusedBottom","viewportTop","viewportBottom","clientHeight","getHighlightedText","text","regex","RegExp","replace","startIndex","floor","endIndex","ceil","displayNodes","slice","transform","isExpanded","isLoading","isSelected","isFocused","isChecked","isDragOver","content","join","find","found","expandAll","expandAndLoadRecursive","async","loadPromises","checkChildren","selectChildren","Promise","all","expandRecursive","collapseAll","selectNode","unselectNode","Array","from","Boolean","clearSelection","cascade","uncheckChildren","setFilter","filterFn","clearFilter","refresh","newData","getData","i","splice","targetId","nodeToInsert","position","ancestorId","descendantId","findNode","checkDescendant","some","ancestorNode"],"mappings":"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"}